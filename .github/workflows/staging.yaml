name: Staging

on: 
  workflow_dispatch

permissions:
  id-token: write
  contents: read

concurrency: staging_environment

env: 
  ENV: staging

jobs:
  tf-setup:
    name: 'Provision staging environment'
    runs-on: ubuntu-latest
    outputs:
      sql-server-encrypted: ${{ steps.terraform.outputs.sql_server_encrypted }}
    environment: staging
    env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_user: ${{ secrets.TF_VAR_postgres_user }}
        TF_VAR_postgres_password: ${{ secrets.TF_VAR_postgres_password }}
        SECRET: ${{ secrets.PGP_PASSPHRASE}}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: 'Terraform Setup'
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_wrapper: false
      - name: 'Initialize Terraform'
        working-directory: ./staging
        run: terraform init
      - name: 'Get state'
        working-directory: ./staging
        run: terraform plan -refresh-only
      - name: 'Make plan'
        working-directory: ./staging
        run: terraform plan -out test.tfplan
      - name: 'Apply plan'
        working-directory: ./staging
        run: terraform apply test.tfplan
      - name: Save outputs
        id: terraform
        working-directory: ./staging
        run: |
          POSTGRES_SERVER=$(terraform output -raw postgres_server)
          postgres_server_encrypted=$(gpg --symmetric --batch --passphrase "$SECRET" --output - <(echo "$POSTGRES_SERVER") | base64 -w0)
          echo "sql_server_encrypted=$postgres_server_encrypted" >> $GITHUB_OUTPUT
          

          
  deploy-frontend:
    name: 'Deploy Frontend'
    needs: tf-setup
    runs-on: ubuntu-latest
    environment: staging
    env: 
        PAT: ${{ secrets.GHP }}
        ACR_LOGIN: ${{ needs.tf-setup.outputs.sql_server_encrypted }}

    steps:
        - name: Dispatch an action and get the run ID
          uses: codex-/return-dispatch@v1
          id: return_dispatch
          with:
            token: ${{ secrets.GHP_RAW }}
            ref: refs/heads/staging
            repo: taro-map
            owner: Kafkaese
            workflow: staging.yaml
            workflow_timeout_seconds: 120
      

        - name: Wait for Deployment Workflow in Frontend Repository
          id: wait
          run: |
            echo "Waiting for frontend deployment to complete..."
            until [[ $(curl -s -X GET -u "$PAT" https://api.github.com/repos/Kafkaese/taro-map/actions/runs/${{steps.return_dispatch.outputs.run_id}} | jq '.status') == '"completed"' ]]; do
              sleep 10
            done
            if [[ $(curl -s -X GET -u "$PAT" https://api.github.com/repos/Kafkaese/taro-map/actions/runs/${{steps.return_dispatch.outputs.run_id}} | jq '.conclusion') != '"success"' ]]; then
              false
            fi

  deploy-backend:
    name: 'Deploy Backend'
    needs: tf-setup
    runs-on: ubuntu-latest
    environment: staging
    env: 
        PAT: ${{ secrets.GHP }}
        SECRET: ${{ secrets.PGP_PASSPHRASE}}

    steps:
        - name: 'Decrypt postgres server'
          run: |
            export pg_host_decrypted=$(gpg --decrypt --quiet --batch --passphrase "$SECRET" --output - <(echo "${{ needs.tf-setup.outputs.sql-server-encrypted }}" | base64 --decode))
            export POSTGRES_HOST=$(jq -n --arg one "$pg_host_decrypted" '{postgres_host: $one}')
            echo $POSTGRES_HOST
            echo "POSTGRES_HOST='$POSTGRES_HOST'" >> "$GITHUB_ENV"
            cat $GITHUB_ENV
        - name: Dispatch an action and get the run ID
          uses: codex-/return-dispatch@v1
          id: return_dispatch
          with:
            token: ${{ secrets.GHP_RAW }}
            ref: refs/heads/staging
            repo: taro-data
            owner: Kafkaese
            workflow: staging.yaml
            workflow_timeout_seconds: 120
            workflow_inputs: ${{ env.POSTGRES_HOST }}
        - name: Wait for Deployment Workflow in Frontend Repository
          id: wait
          run: |
            echo "Waiting for frontend deployment to complete..."
            until [[ $(curl -s -X GET -u "$PAT" https://api.github.com/repos/Kafkaese/taro-data/actions/runs/${{steps.return_dispatch.outputs.run_id}} | jq '.status') == '"completed"' ]]; do
              sleep 10
            done
            if [[ $(curl -s -X GET -u "$PAT" https://api.github.com/repos/Kafkaese/taro-data/actions/runs/${{steps.return_dispatch.outputs.run_id}} | jq '.conclusion') != '"success"' ]]; then
              false
            fi

  tf-destroy:
    name: 'Destroy staging environment'
    if: ${{ always() }}
    needs: [tf-setup, deploy-frontend, deploy-backend]
    runs-on: ubuntu-latest
    environment: staging
    env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3
    - name: 'Terraform Setup'
      uses: hashicorp/setup-terraform@v1
    - name: 'Initialize Terraform'
      working-directory: ./staging
      run: terraform init
    - name: 'Get state'
      working-directory: ./staging
      run: terraform plan -refresh-only
    - name: 'Make plan'
      working-directory: ./staging
      run: terraform plan -destroy -out test.tfplan
    - name: 'Apply plan'
      working-directory: ./staging
      run: terraform apply test.tfplan
